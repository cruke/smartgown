<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Smart Convocation Robe Borrowing System</title>
<style>
:root { --bg:#0f172a; --fg:#e2e8f0; --accent:#22d3ee; --blue:#22d3ee; --red:#ef4444; }
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif}
header{
  position:sticky;top:0;z-index:9999;
  padding:14px 16px;background:#111827;border-bottom:2px solid var(--accent);
  text-align:center;font-size:20px;font-weight:600;color:var(--accent);
}
main{padding:12px 16px;max-width:900px;margin:auto;padding-bottom:92px}

/* Buttons + checkboxes + selects */
button{
  background:#111827;color:var(--fg);
  border:1px solid #374151;border-radius:10px;
  padding:8px 14px;margin:2px;cursor:pointer;
  transition:border-color .2s, box-shadow .2s, background .2s, color .2s, opacity .2s;
}
button:hover{border-color:var(--accent)}
button:disabled{opacity:.5;cursor:not-allowed}
select{
  background:#0b1220;color:var(--fg);
  border:1px solid #334155;border-radius:10px;
  padding:8px 10px;margin:2px;min-width:240px;
}
select:disabled{opacity:.6}
.controls{display:flex;flex-direction:column;gap:10px;margin-bottom:10px}
.controls .row{display:flex;flex-wrap:wrap;gap:6px;align-items:center}
.controls .checkboxes{display:flex;flex-direction:column;gap:6px;padding-left:4px}

/* Torch button ON glow */
.btn-torch.on{
  background:#f59e0b;color:#111827;border-color:#f59e0b;
  box-shadow:0 0 10px #f59e0b80, 0 0 18px #f59e0b50;
}

/* Glowing checkboxes */
label.tick{display:flex;align-items:center;gap:8px;font-size:15px;cursor:pointer;user-select:none;transition:color .3s}
label.tick input{display:none}
label.tick .indicator{width:14px;height:14px;border-radius:3px;border:1px solid #444;background:#2d3748;box-shadow:inset 0 0 3px rgba(0,0,0,0.6);transition:all .3s}
label.tick input:checked + .indicator{background:#10b981;border-color:#10b981;box-shadow:0 0 5px #10b981,0 0 10px #10b98180}
label.tick:hover .indicator{box-shadow:0 0 4px #22d3ee}

/* Frame + canvases */
#frameWrap{position:relative;border:1px solid #334155;border-radius:12px;overflow:hidden;background:#000;margin:10px 0}
#video{display:none}
#view{display:block;width:100%;height:auto}
#overlay{position:absolute;left:0;top:0;width:100%;height:auto;pointer-events:none}
.badge{position:absolute;left:10px;top:10px;background:rgba(0,0,0,.6);padding:6px 10px;border-radius:999px;font-size:12px}

/* Sticky status bar at bottom */
.statusbar{
  position:fixed;left:0;right:0;bottom:0;z-index:9998;
  display:flex;flex-wrap:wrap;gap:8px;justify-content:center;align-items:center;
  padding:10px 12px;border-top:1px solid #243040;
  background:rgba(11,18,32,0.9);backdrop-filter: blur(6px);
}
.pill{display:inline-block;padding:6px 10px;border-radius:999px;font-size:14px;font-weight:600;transition:color .25s,background .25s,box-shadow .25s;border:1px solid #334155;background:#0b1220;color:#cbd5e1}
.pill.idle{color:#a1a1aa;border-color:#374151}
.pill.sending{color:#facc15;border-color:#a16207;box-shadow:0 0 6px #facc1570;position:relative;padding-left:28px}
.pill.sending::before{content:"";position:absolute;left:8px;top:50%;transform:translateY(-50%);width:14px;height:14px;border-radius:50%;border:2px solid rgba(250,204,21,.35);border-top-color:#facc15;animation:pill-spin .9s linear infinite}
@keyframes pill-spin{to{transform:translateY(-50%) rotate(360deg)}}
.pill.success{color:#22c55e;border-color:#15803d;box-shadow:0 0 6px #22c55e90}
.pill.error{color:#ef4444;border-color:#7f1d1d;box-shadow:0 0 6px #ef444480}

/* Summary line */
#summaryLine{text-align:center;margin-top:10px;font-size:16px;font-weight:500;color:#9fe8a3}

fieldset{border:1px solid #334155;padding:8px 12px;border-radius:8px;margin-top:8px}
legend{font-size:14px;color:var(--accent)}
</style>

<!-- ZXing -->
<script type="module">
import { BrowserMultiFormatReader } from "https://cdn.jsdelivr.net/npm/@zxing/library@0.20.0/+esm";
window.ZXING_Reader = new BrowserMultiFormatReader();
</script>
</head>
<body>
<header>üéì Smart Convocation Robe Borrowing System</header>
<main>

<div class="controls">
  <div class="row">
    <select id="cameraSelect" title="Choose camera" disabled>
      <option>Loading cameras‚Ä¶</option>
    </select>
    <button id="startBtn">Start</button>
    <button id="stopBtn" disabled>Stop</button>
    <button id="torchBtn" class="btn-torch" disabled title="Torch not available">Torch</button>
    <button id="testBtn">Test System</button>
  </div>
  <div class="checkboxes">
    <label class="tick"><input type="checkbox" id="beepChk" checked><span class="indicator"></span> Beep</label>
    <label class="tick"><input type="checkbox" id="vibrateChk" checked><span class="indicator"></span> Vibrate</label>
    <label class="tick"><input type="checkbox" id="mirrorChk"><span class="indicator"></span> Mirror camera view</label>
    <label class="tick"><input type="checkbox" id="preventDupesChk" checked><span class="indicator"></span> Prevent duplicate send</label>
  </div>
</div>

<fieldset>
  <legend>Mode Selection</legend>
  <label><input type="radio" name="mode" value="borrow" checked> Borrow</label>
  <label><input type="radio" name="mode" value="return"> Return</label>
</fieldset>

<div id="frameWrap">
  <div id="modeBadge" class="badge">Mode: BORROW</div>
  <video id="video" playsinline></video>
  <canvas id="view"></canvas>
  <canvas id="overlay"></canvas>
</div>

<div id="summaryLine"></div>
</main>

<!-- Sticky pills -->
<div class="statusbar" aria-live="polite">
  <span id="camStatus"   class="pill idle">üì∑ Camera: idle</span>
  <span id="sheetStatus" class="pill idle">üìÑ Sheet: idle</span>
  <span id="tgStatus"    class="pill idle">‚úàÔ∏è Telegram: idle</span>
</div>

<script type="module">
/* ==== CONFIG ==== */
const GAS_URL="https://script.google.com/macros/s/AKfycbyJifwYjoBeZ0SmFc7F7ENJCQfTuquT6QVZHV4aCEfamgFQmtED78IWLeOqSPnXGCo/exec";
const BOT_TOKEN="121011557:AAHE32VqMkQ8AnnXuDAlLXZn6Ybg7mXpyMo";
const CHAT_ID="44305665";
const BLOCK_MS=5000;

/* ==== DOM ==== */
const video=document.getElementById("video"),view=document.getElementById("view"),vctx=view.getContext("2d");
const overlay=document.getElementById("overlay"),ctx=overlay.getContext("2d");
const cameraSelect=document.getElementById("cameraSelect");
const startBtn=document.getElementById("startBtn"),stopBtn=document.getElementById("stopBtn");
const torchBtn=document.getElementById("torchBtn"),testBtn=document.getElementById("testBtn");
const beepChk=document.getElementById("beepChk"),vibrateChk=document.getElementById("vibrateChk"),mirrorChk=document.getElementById("mirrorChk"),preventDupesChk=document.getElementById("preventDupesChk");
const modeBadge=document.getElementById("modeBadge"),summaryLine=document.getElementById("summaryLine");
const camStatus=document.getElementById("camStatus"),sheetStatus=document.getElementById("sheetStatus"),tgStatus=document.getElementById("tgStatus");

/* ==== STATE ==== */
let stream=null,track=null,audioCtx,vw=0,vh=0,cropY=0,cropH=0;
let torchOn=false;
const codeReader=window.ZXING_Reader;
const processedAt=new Map();
/* camera list + selection */
let devices=[], selectedDeviceId=null;

/* Overlay state */
let lastDet=null;          // { points:[{x,y},...], color, label }
let lastDetTime=0;         // performance.now()
let invalidFlashUntil=0;   // timestamp until when to show red flash

/* ==== INIT ==== */
camStatus.className="pill idle";sheetStatus.className="pill idle";tgStatus.className="pill idle";

/* ==== Helpers ==== */
function setPill(el,state,label){el.className=`pill ${state}`;if(label)el.textContent=label;}
function getMode(){return document.querySelector('input[name="mode"]:checked').value;}
document.querySelectorAll('input[name="mode"]').forEach(r=>r.addEventListener('change',()=>modeBadge.textContent="Mode: "+getMode().toUpperCase()));
function beep(){if(!beepChk.checked)return;audioCtx??=new (window.AudioContext||window.webkitAudioContext)();const o=audioCtx.createOscillator(),g=audioCtx.createGain();o.type="sine";o.frequency.value=880;o.connect(g);g.connect(audioCtx.destination);o.start();setTimeout(()=>o.stop(),100);}
function flash(){document.body.style.background="#334";setTimeout(()=>document.body.style.background="#0f172a",150);}
function keyFor(m,t){return`${m}||${t}`;}
function isBlocked(m,t){const k=keyFor(m,t);return(Date.now()-(processedAt.get(k)||0))<BLOCK_MS;}

function populateCameraSelect(list, currentId){
  cameraSelect.innerHTML="";
  if(list.length===0){
    cameraSelect.disabled=true;
    cameraSelect.innerHTML="<option>No camera found</option>";
    return;
  }
  for(let i=0;i<list.length;i++){
    const d=list[i];
    const opt=document.createElement("option");
    opt.value=d.deviceId;
    opt.textContent = d.label || `Camera ${i+1}`;
    cameraSelect.appendChild(opt);
  }
  cameraSelect.disabled=false;
  // select current if provided
  if(currentId){
    const found = list.some(d=>d.deviceId===currentId);
    cameraSelect.value = found ? currentId : list[0].deviceId;
  }else{
    cameraSelect.value = list[0].deviceId;
  }
  selectedDeviceId = cameraSelect.value;
}

/* Map ZXing point to overlay coords (account for crop & mirror) */
function mapPoint(p){
  let x = p.getX ? p.getX() : (p.x ?? 0);
  let y = p.getY ? p.getY() : (p.y ?? 0);
  if (mirrorChk.checked) x = vw - x;  // mirror horizontally
  y -= cropY;                          // shift into middle-crop space
  return { x, y };
}

/* Draw detection box + label */
function drawDet(det){
  if(!det || !det.points?.length) return;
  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
  for(const p of det.points){
    minX=Math.min(minX,p.x);maxX=Math.max(maxX,p.x);
    minY=Math.min(minY,p.y);maxY=Math.max(maxY,p.y);
  }
  const pad=20;
  const x=Math.max(0,minX-pad);
  const y=Math.max(0,minY-pad);
  const w=Math.min(overlay.width, maxX+pad) - x;
  const h=Math.min(overlay.height, maxY+pad) - y;

  ctx.lineWidth=4; ctx.strokeStyle=det.color;
  ctx.strokeRect(x,y,w,h);

  ctx.font="16px system-ui";
  const tw=ctx.measureText(det.label).width;
  ctx.fillStyle="rgba(0,0,0,0.6)";
  ctx.fillRect(x-4,Math.max(0,y-24),tw+10,20);
  ctx.fillStyle=det.color;
  ctx.fillText(det.label,x,y-8);
}

/* ==== Camera device management ==== */
async function listCameras(){
  const all = await navigator.mediaDevices.enumerateDevices();
  devices = all.filter(d => d.kind === "videoinput");
  populateCameraSelect(devices, selectedDeviceId);
}

/* ==== Start/Stop ==== */
async function start(withDeviceId){
  stop();
  try{
    setPill(camStatus,"sending","üì∑ Camera: starting‚Ä¶");

    // Use selected device if available, else environment
    const deviceId = withDeviceId || selectedDeviceId;
    const constraints = deviceId
      ? { video: { deviceId: { exact: deviceId } } }
      : { video: { facingMode: "environment" } };

    stream=await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject=stream;await video.play();
    track=stream.getVideoTracks()[0];

    // Torch capability & UI
    const caps = track.getCapabilities?.() || {};
    const hasTorch = !!caps.torch;
    torchBtn.disabled = !hasTorch;
    torchBtn.title = hasTorch ? "Toggle torch" : "Torch not available";
    torchOn=false; torchBtn.textContent="Torch"; torchBtn.classList.remove("on");

    // Refresh camera list with real labels after permission
    await listCameras();

    // Try to select the current camera in dropdown
    const settings = track.getSettings ? track.getSettings() : {};
    const curId = settings.deviceId;
    if (curId) {
      selectedDeviceId = curId;
      if (devices.some(d=>d.deviceId===curId)) cameraSelect.value = curId;
    }

    startBtn.disabled=true;stopBtn.disabled=false;

    vw=video.videoWidth||640;vh=video.videoHeight||480;
    cropY=Math.floor(vh/3);cropH=Math.floor(vh/3);
    view.width=vw;view.height=cropH;overlay.width=vw;overlay.height=cropH;

    startDecode();startRender();
    setPill(camStatus,"success","üì∑ Camera: on");
  }catch(e){
    console.error(e);
    setPill(camStatus,"error","üì∑ Camera: error");
  }
}

function stop(){
  if(stream){stream.getTracks().forEach(t=>t.stop());stream=null;}
  startBtn.disabled=false;stopBtn.disabled=true;
  setPill(camStatus,"idle","üì∑ Camera: idle");
  // reset torch state & button when stopping
  torchOn=false; torchBtn.textContent="Torch"; torchBtn.classList.remove("on");
  torchBtn.disabled = true; torchBtn.title = "Torch not available";
  stopDecode();stopRender();
  vctx.clearRect(0,0,view.width,view.height);ctx.clearRect(0,0,overlay.width,overlay.height);
}

/* ==== Torch (reliable toggle with own state) ==== */
async function toggleTorch(){
  if(!track) return;
  const caps = track.getCapabilities?.() || {};
  if(!caps.torch){
    torchBtn.disabled = true;
    torchBtn.title = "Torch not available";
    return;
  }
  try{
    torchOn = !torchOn;
    await track.applyConstraints({ advanced: [{ torch: torchOn }] });
    torchBtn.textContent = torchOn ? "Torch Off" : "Torch";
    torchBtn.classList.toggle("on", torchOn);
  }catch(e){
    console.error("Torch toggle error:", e);
    torchOn = false;
    torchBtn.textContent = "Torch";
    torchBtn.classList.remove("on");
  }
}

/* ==== Render loop (video + overlay) ==== */
let renderRunning=false;
function startRender(){
  if(renderRunning) return; renderRunning=true;
  (function loop(){
    if(!renderRunning) return;
    requestAnimationFrame(loop);
    if(!vw||!vh) return;

    // draw cropped camera frame (middle 1/3)
    vctx.save();
    if(mirrorChk.checked){ vctx.translate(view.width,0); vctx.scale(-1,1); }
    vctx.drawImage(video,0,cropY,vw,cropH,0,0,view.width,view.height);
    vctx.restore();

    // overlay
    ctx.clearRect(0,0,overlay.width,overlay.height);

    // brief red flash for invalid reads
    if (performance.now() < invalidFlashUntil) {
      ctx.fillStyle = "rgba(239,68,68,0.25)";
      ctx.fillRect(0,0,overlay.width,overlay.height);
    }

    // recent detection box
    if (lastDet && (performance.now() - lastDetTime) < 220) {
      drawDet(lastDet);
    }
  })();
}
function stopRender(){ renderRunning=false; }

/* ==== Decode ==== */
let decoderRunning=false;
function startDecode(){
  if(decoderRunning) return; decoderRunning=true;
  codeReader.decodeFromVideoDevice(null, video, (res)=>{
    if(!decoderRunning) return;
    if(res) handleDet(res.text, res.resultPoints || []);
  });
}
function stopDecode(){ decoderRunning=false; try{ codeReader.reset(); }catch{} }

/* ==== Detection ==== */
async function handleDet(text, points){
  const mode = getMode();
  const clean = String(text || "").trim();

  // Map points for overlay (adjust for crop & mirror)
  const mapped = (points || []).map(mapPoint).filter(p => Number.isFinite(p.x) && Number.isFinite(p.y));

  // üö´ Ignore blank or "0" readings; flash red overlay briefly
  if (!clean || clean === "0") {
    invalidFlashUntil = performance.now() + 160; // ~0.16s
    lastDet = { points: mapped, color: "#ef4444", label: "Invalid" };
    lastDetTime = performance.now();
    return;
  }

  // If blocked by per-mode cooldown, show red box + label, but do nothing else
  if (isBlocked(mode, clean)) {
    lastDet = { points: mapped, color: "#ef4444", label: "Blocked" };
    lastDetTime = performance.now();
    return;
  }

  // Mark processed now if prevention is enabled
  if (preventDupesChk.checked) processedAt.set(keyFor(mode, clean), Date.now());

  // Visual/Audio feedback
  flash();
  beep();
  if (vibrateChk.checked && navigator.vibrate) navigator.vibrate(80);

  // Show blue detection box with the content
  lastDet = { points: mapped, color: getComputedStyle(document.documentElement).getPropertyValue('--blue').trim() || "#22d3ee", label: clean };
  lastDetTime = performance.now();

  // Snapshot + send
  const snap = await captureSnap();
  const caption = `üì∑ ${mode.toUpperCase()} Scan\n‚Ä¢ Data: ${clean}\n‚Ä¢ Time: ${new Date().toLocaleString()}`;

  const s = await sendSheet(clean, snap, mode);
  const t = await sendTg(snap, caption);
  if (s.ok) await updateSummaryFromSheet(clean, mode);
}

/* ==== Capture ==== */
async function captureSnap(){
  const c=document.createElement("canvas");c.width=view.width;c.height=view.height;const cx=c.getContext("2d");
  if(mirrorChk.checked){cx.translate(c.width,0);cx.scale(-1,1);}
  cx.drawImage(video,0,cropY,vw,cropH,0,0,c.width,c.height);
  return new Promise(r=>c.toBlob(b=>r(b),"image/png",0.95));
}
function blobToDataURL(b){return new Promise(r=>{const f=new FileReader();f.onload=()=>r(f.result);f.readAsDataURL(b);});}

/* ==== Network ==== */
async function sendSheet(id,blob,mode){
  try{
    setPill(sheetStatus,"sending","üìÑ Sheet: sending‚Ä¶");
    const img=blob?await blobToDataURL(blob):"";
    const body={mode,id,qr:id,url:location.href,image:img};
    const r=await fetch(GAS_URL,{method:"POST",headers:{"Content-Type":"text/plain"},body:JSON.stringify(body)});
    const t=await r.text();let j;try{j=JSON.parse(t);}catch{j={ok:false,error:t};}
    setPill(sheetStatus,j.ok?"success":"error",j.ok?"üìÑ Sheet: updated":"üìÑ Sheet: error");
    return j;
  }catch(e){setPill(sheetStatus,"error","üìÑ Sheet: network error");return{ok:false,error:e.message};}
}
async function sendTg(blob,caption){
  try{
    setPill(tgStatus,"sending","‚úàÔ∏è Telegram: sending‚Ä¶");
    const fd=new FormData();fd.append("chat_id",CHAT_ID);fd.append("caption",caption);fd.append("photo",blob,"frame.png");
    const r=await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`,{method:"POST",body:fd});
    const j=await r.json();setPill(tgStatus,j.ok?"success":"error",j.ok?"‚úàÔ∏è Telegram: sent":"‚úàÔ∏è Telegram: error");return j;
  }catch(e){
    setPill(tgStatus,"error","‚úàÔ∏è Telegram: network error");return{ok:false,error:e.message};
  }
}

/* ==== Test System (no append to sheet) ==== */
testBtn.onclick=async()=>{
  setPill(sheetStatus,"sending","üìÑ Sheet: ping‚Ä¶");setPill(tgStatus,"idle","‚úàÔ∏è Telegram: idle");
  const blob=await captureSnap();
  let sheetOk=false;
  try{const r=await fetch(GAS_URL+"?action=ping");const j=await r.json();sheetOk=!!j.ok;}catch{}
  setPill(sheetStatus,sheetOk?"success":"error",sheetOk?"üìÑ Sheet: OK":"üìÑ Sheet: fail");
  setPill(tgStatus,"sending","‚úàÔ∏è Telegram: sending‚Ä¶");
  const cap=`üß™ System Test\n‚Ä¢ Time: ${new Date().toLocaleString()}\n‚Ä¢ Note: Sheet ping only (no append)`;
  await sendTg(blob,cap);
};

/* ==== Fetch Name & Summary ==== */
async function updateSummaryFromSheet(id,mode){
  try{
    const r=await fetch(`${GAS_URL}?action=getlatest&id=${encodeURIComponent(id)}`);
    const j=await r.json();const now=new Date().toLocaleString();const action=mode.toUpperCase();
    if(j.ok&&j.row){
      const personName=j.row.name&&j.row.name.trim()?j.row.name.trim():null;
      if(personName){summaryLine.style.color="#9fe8a3";summaryLine.innerHTML=`${personName} (${id}) <b>${action}ED</b> a robe at ${now}`;}
      else{summaryLine.style.color="#f87171";summaryLine.innerHTML=`‚ö†Ô∏è Unknown name for ID (${id}) <b>${action}ED</b> a robe at ${now}`;}
    }else{summaryLine.style.color="#f87171";summaryLine.textContent=`‚ö†Ô∏è No record found for ID (${id}).`;}
  }catch{summaryLine.style.color="#f87171";summaryLine.textContent=`‚ö†Ô∏è Error retrieving name for ID (${id}).`;}
}

/* ==== Bind ==== */
cameraSelect.onchange = () => { selectedDeviceId = cameraSelect.value; };
startBtn.onclick = () => start(selectedDeviceId);   // start with chosen camera (or environment if none)
stopBtn.onclick = stop;
torchBtn.onclick = toggleTorch;

/* Prepare initial list (labels may be blank before permission) */
navigator.mediaDevices?.enumerateDevices?.()
  .then(()=>listCameras())
  .catch(()=>{ cameraSelect.innerHTML="<option>Camera permissions required</option>"; });
</script>
</body>
</html>
